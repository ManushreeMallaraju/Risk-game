%description: Math 290 HW Template

%%%%% Beginning of preamble %%%%%

\documentclass[12pt]{article}  %What kind of document (article) and what size

%Packages to load which give you useful commands
\usepackage{subfig}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{amssymb, amsmath, amsthm}

%Sets the margins

\textwidth = 6.5 in
\textheight = 9 in
\oddsidemargin = 0.0 in
\evensidemargin = 0.0 in
\topmargin = 0.0 in
\headheight = 0.0 in
\headsep = 0.0 in
\parskip = 0.2in
\parindent = 0.0in

%defines a few theorem-type environments
% \newtheorem{theorem}{Theorem}
% \newtheorem{corollary}[theorem]{Corollary}
% \newtheorem{definition}{Definition}

\newtheorem{definition}{Definition}
\newtheorem{fact}{Fact}
\newtheorem{remark}{Remark}
\newtheorem{theorem}{Theorem}
\newtheorem{proposition}{Proposition}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}

\renewcommand{\labelenumi}{\arabic{enumi}.}
\renewcommand{\labelenumii}{\arabic{enumi}.\arabic{enumii}.}
\renewcommand{\labelenumiii}{\arabic{enumi}.\arabic{enumii}.\arabic{enumiii}.}
\renewcommand{\labelenumiv}{\arabic{enumi}.\arabic{enumii}.\arabic{enumiii}.\arabic{enumiv}.}
\newlength{\alginputwidth}
\newlength{\algboxwidth}
\newcommand{\alginput}[1]{\makebox[1.5cm][l]{ {\sc Input:}} \parbox[t]{\alginputwidth}{{\it #1}}}
\newcommand{\algoutput}[1]{\makebox[1.5cm][l]{ {\sc Output:}} \parbox[t]{\alginputwidth}{{\it #1}}}
\newcommand{\algtitle}[1]{\underline{Algorithm \ {\bf #1}} \vspace*{1mm}\\}

%%%%% End of preamble %%%%%







\begin{document}

\title{AI for Risk Game}

\author{
{Wah Loon Keng}\thanks{
Lafayette College,
Easton, PA 18042, USA.
kengw{\tt @}lafayette.edu.}
\qquad
{Benjamin H. Draves}\thanks{
Lafayette College,
Easton, PA 18042, USA.
dravesb{\tt @}lafayette.edu.}
      % \affaddr{Department of Computer Science}\\
%       \affaddr{Lafayette College}\\
%       \affaddr{Easton, PA 18042, USA}\\
%       \email{gexia@cs.lafayette.edu}
}
% \date{}
\maketitle

\begin{abstract}
We implement an AI to play the board game $\emph{Risk}$. The game is formalized as an optimization problem in graph theory, where countries are represented as nodes in an undirected graph, and decisions are considered based on the graph properties. We introduce solution algorithms, with variable parametrizations, which are then implement as AIs with different personalities in {\tt JavaScript}. We set up games among AIs to measure their performances, and discover unusual game strategies.
\end{abstract}










\section{Introduction} \label{intro}

The board game $\emph{World Domination RISK \circledR}$ is a game of military strategy, where players of different factions try to conquer all 42 countries on the map, by deploying armies to attack and defend. We use the classic $\emph{Hasbro}$ version of the game; the rules are well known and can easily be found online, but they will be included as we walk through our algorithms.

In this paper, we first set up our formalization of the game as a graph optimization problem. Next we introduce graph algorithms to carry out each of the game moves, and explain our reasoning behind them. Then, we combine these to implement an AI, with variable personalities based on the parametrization of its internal algorithms. The different AIs then play multiple games against one another, with their results recorded. Finally, we analyze their performances, and find several unusual, interesting strategies discovered by the AIs that are never observed from human players.

This entire project is public on GitHub: \url{https://github.com/kengz/Risk-game}.



\section{Formalization} \label{formalization}

The game is inherently dependent on the board, which is a world map of 42 countries, interconnected in specific ways. Decisions to attack or defend are based on the distribution of the armies, the surroundings of a location, and connectivity of countries. These motivate our formalizing the game board and algorithms based on an undirected graph. From now we shall refer to the graph representation as $\emph{map}$:

\begin{definition} \label{map}
A $\textbf{map}$ is a connected, undirected planar graph, with 42 nodes, each representing a country. The nodes are named with indices $0-41$, and are connected the same way as are countries on the game board by undirected edge of weight 1.
\end{definition}

We assign data fields to each node, namely its country name, the continent it is in, its player owner, the number of armies of the owner in it, its worth and pressure as determined by some metric described below.


\begin{definition} \label{region}
A $\textbf{region}$ is a connected subgraph consisting of nodes all owned by the same player. Each player can own many regions, which together partition the map.
\end{definition}

\begin{definition} \label{border}
A $\textbf{border}$ node of an AI is its node that is adjacent to at least an enemy node.
\end{definition}

\begin{definition} \label{attackable}
A $\textbf{attackable}$ node for an AI an enemy node adjacent to its border.
\end{definition}

\begin{definition} \label{shape}
The $\textbf{shape}$ of a region is the measure of its shape/roundess. To compute the shape, find the maximum and minimum distances between the border nodes in the region, and shape=(max-min)/max. If a region is round, shape = 0; if it is a line, shape = 1.
\end{definition}

\begin{definition} \label{radius}
$\textbf{Radius}$ is the measure of shortest distance from an origin node. We identify the neighbors of node $\mathcal{O}$ at radius k to be the nodes whose shortest distance from $\mathcal{O}$ is k.
\end{definition}


Furthermore, we define the fields that will be useful in our algorithms:

\begin{definition} \label{worth}
The $\textbf{worth}$ of a node is the measure of its importance to an AI, as calculated by its internal metric algorithm, and is used by the AI to prioritize its decisions: which node should it defend/attack first.
\end{definition}

\begin{definition} \label{pressure}
The $\textbf{pressure}$ of a node as perceived by an AI is the measure of the average army distribution around the node, up to 5 unit radii away. It is calculated by the AI's internal metric and used to prioritize decisions.
\end{definition}

Note that the worth and pressure of a node are not the same when calculated by opposing AIs due to different perceptions, metric and AI personalities. Each AI will be calculating these values for all 42 nodes at each turn.

Finally, we introduce a data structure as the raw representation of overall army distribution on the map for various calculations:

\begin{definition} \label{RMAM}
The $\textbf{Radius Matrix (RM)}$ from an origin node $\mathcal{O}$ is the matrix that better represents the connectivity of neighbor nodes of the origin within some radius. It is enumerated by the Radius Matrix Algorithm below, and each entry is the name of some node.

Its corresponding $\textbf{Army Matrix (AM)}$ is a different representation of the RM, with each entry now being $z \in \mathbb{Z}$, where $|z|$ is the number of armies at the node, and $z$ is positive if the node is owned by the calculating AI, and negative otherwise.
\end{definition}







\section{Algorithms}

We now enumerate the algorithms for each step of the game, which will collectively form the final algorithm used by the AI to play the game.


\subsection{The Matrix Algorithms}

\algtitle{Radius Matrix (RM) for an origin node $\mathcal{O}$}
Starting from an origin node $\mathcal{O}$, initialize an empty matrix for its RM,
\begin{enumerate}
	\item Add the index of each adjacent node (at radius 1) of $\mathcal{O}$ to a new row in RM.
	\item Repeat for $i \in \{2,3,...,n\}$, where $n$ is the maximum radius covered:
	
	For each entry $p$ at column $i$, get all $n_p$ of its adjacent nodes at radius $i+1$ from $\mathcal{O}$. 

	\item Duplicate the row of entry $p$ while appending to it each of the $n_p$ adjacent nodes at column $i+1$. If $n_p=0$, append $``empty"$ instead. The process is akin to a Cartesian product.

	\item Return the RM for $\mathcal{O}$.
\end{enumerate}

Note that the column number will coincide with the radius from $\mathcal{O}$. The RM with $n$ columns is a representation of the connectivity from the origin up to radius $n$, where each row is the shortest path from the origin to a point at radius $n$, and there may exist many such paths.

\algtitle{Army Matrix (AM) for an origin node $\mathcal{O}$}
We can convert an RM into AM, a representation using the number of armies,
\begin{enumerate}
	\item Find the RM for node $\mathcal{O}$ using the RM algorithm.
	\item For each entry $p$ in RM, if node $p$ has the same owner as $\mathcal{O}$, replace the entry with the number of army at $p$; else, replace with the negative of the number of army at $p$. If an entry $p$ is $``empty"$, append 0 instead.
	\item return the AM for $\mathcal{O}$.
\end{enumerate}


This transforms an RM into its alternate form AM, which gives a representation of the army distribution and connectivity around the origin node $\mathcal{O}$. This matrix can be used for calculating the $\textbf{pressure}$ from definition \ref{pressure}. For our project we calculate the matrices up to radius 5, which we think is sufficient given that per game turn a player can only move adjacently among nodes.





\subsection{The Pressure Algorithm}

The pressure of each node from an AI's point of view is the average number of army surrounding the node. More positive pressure indicates the node is a better stronghold of the AI; more negative pressure indicates is surrounded by more enemies.

The calculation of pressure depends on the AI's perception of threat, which can be represented using a metric that varies based on its personality.

\begin{definition}
The $\textbf{threat perception}$ of an AI is the way it sees the threat of army distribution up to some radius away poses on an origin node. E.g. 10 enemy armies further away poses less threat than 5 enemy armies nearby. The $\textbf{threat perception}$ is quantified by defining a metric: a normalized vector or length = max radius of AM, where the individual value of the vector is the weight multiplied to the army number at that radius. The procedure is describe below.
\end{definition}

\algtitle{The Metric Algorithm}
To enumerate the metric for an AI's threat perception, with scope radius = 5,
\begin{enumerate}
	\item Choose a weight function, for example, constant, Gaussian,
	\item Evaluate function values for with the input distance vector $\{1,2,3,4,5\}$
	\item Renormalize the output vector and return it as the metric vector.
\end{enumerate}

This metric vector $\mathbf{w}$ is then dotted with a row $\mathbf{r}$ in the AM, which is a list of number of armies at incremental distance away from an origin node $\mathcal{O}$, and the partial pressure $\emph{PP}$ for it is:
$$\emph{PP}(\mathbf{r}) = \mathbf{w} \cdot \mathbf{r}$$


\algtitle{The Pressure Algorithm}
The AI calculates the pressure for each node using its personality trait $\textbf{weight-function}$, or the metric vector $\mathbf{w}$:
\begin{enumerate}
	\item Update the data fields of the map and call the AM algorithm to compute the AMs for all 42 nodes.
	\item For each node $\mathcal{O}$, compute the dot product between $\mathbf{w}$ and each row of the node's AM; the result is a column vector $\mathbf{c}$.
	\item The first column of the original RM is a repeated list of $m$ adjacent nodes of $\mathcal{O}$, suppose each node $i$ repeats $q_i$ times in the column, so in total the column has length $q_1 + q_2 + \cdots + q_m$. Renormalize this sequence into $nq_1 + nq_2 + \cdots + nq_m$ For each batch $q_i$ of the column vector $\mathbf{c}$ from above, take its mean, then multiply by the renormalized weight $nq_i$. Then sum all $m$ of the results, call this scalar $s(\mathcal{O})$.
	\item Now that the column $\mathbf{c}$ has been reduced to a scalar representing the average army distribution around the origin $\mathcal{O}$, account for the number of armies (sign-sensitive, negative for enemy) here $a(\mathcal{O})$ by adding the scalar, and return the pressure of node $\mathcal{O}$, $P(\mathcal{O}) = s(\mathcal{O}) + a(\mathcal{O})$.
\end{enumerate}


Thus at each turn, the AI updates the data fields and calculates the pressure, i.e. the average number of surrounding armies, for each node, using its threat perception metric.




\subsection{The Worth Algorithm}

\algtitle{The Worth Algorithm}
At each turn, the AI evaluates the worth of each node to prioritize its attacks and defenses. Suppose it considers $m$ factors, each of which assumes a real positive value, with more positive being more worthy. To compute the final worth scalar, simply order the $m$ factors from the most vital, and dot it with a factor vector $\{10^{m-1}, ..., 100, 10, 1\}$.

For our AI, we consider the following factors (ordered from the most important). For each node $\mathcal{O}$ calculate and append to the list of factors:

\begin{enumerate}
	\item continent-fraction = $\frac{\text{(number of nodes with the same owner in the same continent $\mathcal{O}$)}}{\text{(total number of nodes in the continent)}}$
	\item If $\mathcal{O}$ is own node, the region-index: Enumerate for each player its nodes, and group them by regions, then order them from the biggest to the smallest regions. The region-index of $\mathcal{O}$ is its index in this list. Or if $\mathcal{O}$ is enemy, the attackable index: of the region list enumerated above, extract the sublist with nodes that are attackable, i.e. is an enemy adjacent to one of your nodes. The attackable index of $\mathcal{O}$ is its index in this sublist; -1 otherwise.
	\item shape: find the region $\mathcal{O}$ is in and compute the shape as in definition \ref{shape}.
	\item degree: the degree of $\mathcal{O}$, i.e. the number of adjacent nodes it has.
	\item pressure: as calculated from the pressure algorithm.
	\item Finally, return the dot product between this factor list and $\{10^{4}, 1000, 100, 10, 1\}$.
\end{enumerate}


After obtaining an ordered list of worth nodes, we can partition it while preserving the order into lists of border nodes and attackable nodes, and reorder them based on strategies. Furthermore, the AI makes it context-sensitive by remembering the pressures from the past turn, and reorder the list based on pressure-drop between turns.





\subsection{The Priority Algorithm}
At each game turn, the AI updates the priority nodes to attack/defend. The list of priority nodes depends on the AI's personality trait $\textbf{priority}$, whether it is agressive (attack-then-defend) or defensive (defend-then-attack).

\algtitle{The Priority Algorithm}
\begin{enumerate}
	\item Update the data fields for the AI.
	\item Call the pressure algorithm on the map.
	\item Call the worth algorithm on the map.
	\item Repartition the worth nodes and reorder by attackables/borders first based on the AI's personality, whether agressive or defensive. Furthermore, for the attackable, choose the best origin of attack by the highest pressure.
\end{enumerate}







\subsection{The Placement Algorithm}
This describes how the AI places the armies into the its priority nodes based on its personality trait $\textbf{placement}$.

\algtitle{The Placement Algorithm}
\begin{enumerate}
	\item If the trait is $\textbf{cautious}$, place armies along its  priority nodes (if is enemy, use the best origin of attack) until all pressures are $>0$, then with the extra armies, place 4 each down the same list; repeat until none left.
	\item If the trait is $\textbf{tactical}$, place armies down the list until node pressure is $>4$, then with extra, place 4 each down the list; repeat until none left.
\end{enumerate}







\subsection{The Attack Algorithm}
The AI decides to launch attacks from the best attack origin (calculate with in priority list) based on its personality trait $\textbf{attack}$.

\algtitle{The Attack Algorithm}
For all attackables down the priority list,
\begin{enumerate}
	\item If the trait is $\textbf{rusher}$, the AI harassess constantly, i.e. while the best attack origin has 2 more armies than the enemy target, keep attacking before moving to next target.
	\item If the trait is $\textbf{carry}$, same as above, but the difference threshold is 4 (higher). Furthermore, the AI will accumulate the cards to reserve more armies for late game.
\end{enumerate}








\subsection{The Fortifying Algorithm}
All AIs use the same fortifying algorithm.

\algtitle{The Fortifying Algorithm}

\begin{enumerate}
	\item Find the border node $\mathcal{O}$ with the lowest pressure, and find a non-border ally node with higher pressure, transfer all but 1 troop to the border node if possible. This is to always push the unused central forces out to the borders where armies are mostly needed.
	\item If no fortification done above, find a border node with the highest pressure, and transfer any neighboring armies (all but 1) to it. This is for the accumulation of armies during late game by making strong node even stronger.
\end{enumerate}












We are now ready to enumerate the algorithms for the game steps. Each turn of the game consists of three stages:

\begin{enumerate}
\item Getting and placing new armies;
\item Attacking, if you choose to, by rolling the dice; 
\item Fortifying your position (moving troops between an adjacent pair of your nodes).
\end{enumerate}

Before carrying out any of these steps, the AI first has to $\textit{judge}$ the worth of the nodes. This is done by the Priority Algorithm:










Draft:

1. Formalization of problem

2. Algorithms and decisions

3. AI Implementation and variations

4. results, performance, analysis

5. AI behaviors, surprises



\begin{definition}
A block code is a rectangular array of $n$-nary letters (entries), with non-repeating columns and rows. Notate any block code of $n$-nary, $p$-columns and $k$-rows as 
$$BC(n,p,k)$$
where the letters are elements of the set $\mathcal{M}=\{1,2,\dots,n\}$. 
It is easy to see that $1\leq k \leq n^p$ due to the non-repeating columns and rows.
\end{definition}

Equivalently, a block code is a collection of $n$-nary codewords (the rows) of length $p$ (number of columns). Below is an example of block code with $n=2,p=3$, with the maximum number of $2^3=8$ rows. It is a listing of $\{0,1,2,\dots,7\}$ in binary.\footnote{For readability, block codes come with brackets in this paper; we do not consider matrix operations.}
$$BC(2,3,2^3)=
\left[\begin{array}{ccc}
0 & 0 & 0 \\
0 & 0 & 1 \\
0 & 1 & 0 \\
0 & 1 & 1 \\
1 & 0 & 0 \\
1 & 0 & 1 \\
1 & 1 & 0 \\
1 & 1 & 1 \\
\end{array}\right]
$$

Block codes are equipped with the following set of three operations, under which a block code is still considered to be equivalent to the original:
\begin{flalign}
\emph{Column-swapping}\\
\emph{Row-swapping}\\
\emph{Column-wise letter-permutation}\footnote{equivalent to row-swapping when applied to a transposed block code.}
\end{flalign}

To illustrate the operations, take a ternary block code with the operations:
$$BC(3,2,3) = \left[\begin{array}{cc}1 & 2\\ 1 & 3\\ 2 & 2\end{array}\right]$$
$$\text{permutation to column 1: \ } 1 \mapsto 3, \ 2 \mapsto 2,\ 3 \mapsto 1$$
$$\text{permutation to column 2: \ } 1 \mapsto 2, \ 2 \mapsto 3,\ 3 \mapsto 1$$
$$\text{swap the columns}$$

The resultant block code is then 
$$\left[\begin{array}{cc}1 & 2\\ 1 & 3\\ 2 & 2\end{array}\right]
\mapsto
\left[\begin{array}{cc}3 & 2\\ 3 & 3\\ 2 & 2\end{array}\right]
\mapsto
\left[\begin{array}{cc}3 & 3\\ 3 & 1\\ 2 & 3\end{array}\right]
\mapsto
\left[\begin{array}{cc}3 & 3\\ 1 & 3\\ 3 & 2\end{array}\right]$$

Any block code generated by these operations is considered equivalent to the original. Thus, the operations allow us to define class on the block codes.


\begin{definition}
A class is a collection of a block code and all the possible block codes obtained by applying these operations to it. Thus, any block codes are said to be equivalent(in the same class) if and only if they can be made identical using these operations.
\end{definition}


\noindent{\bf Comment.} This problem is originally motivated by a research in Quantum Foundations: the classification of Hardy-type paradoxes. Consider an experiment setup of $p$-parties, $n$-nary party-outcome, with $k$ possible outcomes. The setup is still physically equivalent under the relabeling of parties (column swapping), reordering of the occurence of outcomes (row-swapping), and relabeling of party-outcome (column-wise letter-permutation). Thus it is sufficient to study only a representative of these equivalent setups.
















\section{Problem Statement}

The problem is to identify the class of a block code, or to determine whether two block codes are equivalent (whether they belong to the same class). This is equivalent to the generalization of the problem of canonicalizing matrices:

\noindent{\bf Special case.} Given two matrices of the same size, determine whether or not they can be identical under row and column swapping.

\noindent{\bf General case.} The same as above, but with an additional operation of column-wise letter-permutation (or row-wise letter-permutation when a matrix is transposed).


\textit{Fripertinger `98} computed the number of classes for block codes $BC(n,p,k)$ for up to $n=7$, and later produced the representatives of these classes by rewriting them using vectors of $n$-adic numbers. However, the number of block codes, and the number of distinct classes, increases quickly due to combinatorial explosion even when the parameters $n,p,k$ are small. 

This makes it unfeasible to identify the classes or determine the equivalence between block codes by exhaustive generation and comparison of all the class members.













\section{The Bundled Form and Algorithm}
We now present a non-exhaustive algorithm that solves the problem. The main idea is to transform a given block code using the allowed operations into a unique, canonical form of the class, called the \textit{Bundled Form}. The problem is solved by directly comparing the \textit{Bundled Forms} of the block codes.














\subsection{Notations and Definitions}
$BC(n,p,k)$: \emph{The generic block code} specified by three parameters: $n$-nary entries, $p$-columns, $k$-rows, where $k \leq n^p$. Block codes obey the three operations of column-swapping, row-swapping, and column-wise letter-permutation. To distinguish a specific instance of the generic block code, index it with subscript $b$, like $BC(n,p,k)_b$.


$\mathcal{S}^c_{i\dots j}$: \emph{Bundle}. It is a sub-column containing only identical letters. Obviously, one can swap the rows of a block code to result in a column having nicely bundled entries, i.e. identical letters are grouped together in the column, and the bundles form the column.


The superscript $c$ specifies the column of the block code the \emph{bundle} resides. The subscript $i\dots j$ is a number sequence of length $c$, $j$ indexes the bundles down the $c$-column of the block code.



$||\mathcal{S}^c_{i\dots j}||$: \emph{The length} of \emph{bundle}: the number of identical letters in it.


$\mathcal{B}(\mathcal{S}^c_{i\dots j})$: \emph{The sub-block code} $BC(n, p-c, ||\mathcal{S}^c_{i\dots j}||)$ on the right of the \emph{bundle} $\mathcal{S}^c_{i\dots j}$, spanning the columns $c+1,\dots,p$ and the same rows as the bundle. For generality, call the original block code a sub-block code of its super-bundle $\mathcal{S}^0$, so $BC(n,p,k) = \mathcal{B}(\mathcal{S}^0)$.


$\mathcal{S}^{c+1}_{i\dots j h}$: \emph{Sub-bundle} of the bundle $\mathcal{S}^c_{i\dots j}$ immediately right to the bundle, i.e. it is a bundle of the sub-block code $\mathcal{B}(\mathcal{S}^c_{i\dots j})$.

Now we can write the sub-block code as:
$$\mathcal{B}(\mathcal{S}^c_{i\dots j}) = \{
\mathcal{S}^{c+1}_{i\dots j h}, 
\mathcal{S}^{c+2}_{i\dots j h g}, 
\mathcal{S}^{c+3}_{i\dots j h g f}, 
\dots, 
\mathcal{S}^{p}_{i\dots j h g f \dots e}
\}$$
where the subscript variables range on separate valid index sets.

For a fixed bundle $\mathcal{S}^c_{i\dots j}$ with a fixed $j$-value, we have a fixed sub-block code $\mathcal{B}(\mathcal{S}^c_{i\dots j})$ on its right. Since we can perform swapping on the rows spanned by the sub-block code, we can get nicely-bundled entries on the $(c+1)$-column. $h$ indexes the sub-bundles $\{\mathcal{S}^{c+1}_{i\dots j h} : 1 \leq h \leq n \}$ that form the column. Since we require that the same entries be bundled together, and there can be at most $n$-different $n$-nary letters, we get $j \leq n$.


Note that the definitions of sub-block code and sub-bundles are recursive. Symmetrically we can define super-bundles of the sub-bundles. The recursive process of partitioning the block code into smaller bundles ``refines'' it as we proceed from column $1$ to $p$. Also note that no sub-bundle can belong to different super-bundles. 

Furthermore, since there can be no repeating rows in a block code, the ``finest refinement'' must be reached at column $p$, i.e. $||\mathcal{S}^p_{i\dots q}|| = 1$, or else there will be more than one rows that share the same super-bundles all the way from column $p$ to $1\ $-  a contradiction.


We give an example to illustrate the concept of sub-bundles and sub-block codes.

$$\newcommand*{\temp}{\multicolumn{1}{c|}{0}}
BC(3,3,6)_1=
\left[\begin{array}{ccc}
1 & 1 & 1\\ 
1 & 2 & 2\\ 
3 & 2 & 1\\ 
2 & 3 & 2\\ 
1 & 2 & 1\\ 
2 & 3 & 1\\ 
\end{array}\right] 
\mapsto
\left[\begin{array}{ccc}
1 & 2 & 1\\ \cline{3-3} 
1 & 2 & 2\\ \cline{2-3} 
1 & 1 & 1\\ \cline{1-3} 
2 & 3 & 1\\ \cline{3-3} 
2 & 3 & 2\\ \cline{1-3} 
3 & 2 & 1\\ \cline{1-3} 
\end{array}\right]
=
\left[\begin{array}{ccc}
\mathcal{S}^1_{1} 	& \mathcal{S}^2_{1,1} & \mathcal{S}^3_{1,1,1}\\ \cline{3-3} 
\vdots	 			& \vdots & \mathcal{S}^3_{1,1,2}\\ \cline{2-3} 
\vdots 				& \mathcal{S}^2_{1,2} & \mathcal{S}^3_{1,2,1}\\ \cline{1-3} 
\mathcal{S}^1_{2} 	& \mathcal{S}^2_{2,1} & \mathcal{S}^3_{2,1,1}\\ \cline{3-3} 
\vdots				& \vdots & \mathcal{S}^3_{2,1,2}\\ \cline{1-3} 
\mathcal{S}^1_{3} 	& \mathcal{S}^2_{3,1} & \mathcal{S}^3_{3,1,1}\\ \cline{1-3} 
\end{array}\right]
$$


Above, we pick a member of the generic block code $BC(3,3,6)$. No column-swapping is performed. We swap the rows to result in bundles $\mathcal{S}^1_{1}, \mathcal{S}^1_{2}, \mathcal{S}^1_{3}$ on the first column. These bundles and their sub-block codes are partitioned from each other by horizontal lines. Then, for each bundle $\mathcal{S}^1_{i}$, we swap the rows to obtain sub-bundles in the sub-block codes, and repeat the process recursively, refining the original block code down to the last column. 


For example, look at the first bundle $\mathcal{S}^1_{1}$. Because the letter `1' occurs three times, $||\mathcal{S}^1_{1}||=3$. Recursive bundle-refinement on the sub-block codes (and sub-sub-block codes) give finer sub-bundles $\mathcal{S}^2_{1,1},\mathcal{S}^2_{1,2}$, and $\mathcal{S}^3_{1,1,1},\mathcal{S}^3_{1,1,2},\mathcal{S}^3_{1,2,1}$. In terms of sub-block codes,
$$\mathcal{B}(\mathcal{S}^1_{1}) =
\{\mathcal{S}^2_{1,1},\mathcal{S}^2_{1,2}, \mathcal{S}^3_{1,1,1},\mathcal{S}^3_{1,1,2},\mathcal{S}^3_{1,2,1}\}=
\{\mathcal{S}^2_{1,1},\mathcal{S}^2_{1,2}, \mathcal{B}(\mathcal{S}^2_{1,1}),\mathcal{B}(\mathcal{S}^2_{1,2}) \}$$
$$\mathcal{B}(\mathcal{S}^2_{1,1}) = \{ \mathcal{S}^3_{1,1,1},\mathcal{S}^3_{1,1,2}\},\ \ \ \ \ \ \ \mathcal{B}(\mathcal{S}^2_{1,2}) = \{ \mathcal{S}^3_{1,2,1}\}$$



Now that we have the notation of bundles and sub-block codes, we can proceed to define the unique, canonical \textit{Bundled Form}. This is done by using the \textit{Bundled Form Algorithm}, which transforms a block code using the allowable operations.














\subsection{Characteristics of The Bundled Form}

With the notations and concepts, we can characterize the \emph{Bundled Form}. It is basically a reordering of the sub-bundles and sub-block codes via row and column swapping such that for all $c \in \{1,2,\dots,p\}$ and for all $ i,j,h,e \in \{\emph{some valid index set}\}$:
\begin{align}
||\mathcal{S}^{c}_{i \dots j}|| \geq
||\mathcal{S}^{c}_{i \dots j+1}||\\
||\mathcal{S}^{c+1}_{i \dots j,h}|| \geq
||\mathcal{S}^{c}_{i \dots j}||\\
||\mathcal{S}^{c+1}_{i \dots j,h}|| \geq
||\mathcal{S}^{c+1}_{i \dots j+1,h}||\\
||\mathcal{S}^{p}_{i \dots j,h,\dots,e}||=1
\end{align}

In addition to these, there's a final characteristic which gives uniqueness to the Bundled Form. The description is part of the algorithm (refer to Lemma \ref{lem:uniq}).











\subsection{The Bundled Form Algorithm}

The algorithm essentially ranks all the possible bundling of a block code and pick one with the higest rank (see Lemma \ref{lem:uniq}). Starting from a given block code $BC(n,p,k)_b=\mathcal{B}(\mathcal{S}^0)$, apply the algorithm recursively to it and the sub-block codes $\mathcal{B}(\mathcal{S}^c_{i\dots j})$ starting from $c=0$ until it terminates at column $c=p$.

Note that whenever columns and rows are swapped, and letters are permuted on columns, even when mentioned in the context of sub-block codes, it is understood that they are always performed on the entire block code $\mathcal{B}(\mathcal{S}^0)$, so that it obeys the operations and stay in the same class.


\begin{enumerate}
\item Focus on the block code $\mathcal{B}(\mathcal{S}^c_{i \dots j})$. Scan each of its columns, and look for the highest number of letter-repetition. Note that there may be more than one such column. Call this \emph{multiplicity}. For later comparison, index them with $t \in \mathcal{T}$, where $\mathcal{T}$ is some valid index set. For each of these columns:

\begin{enumerate}
\item Move this $t$-column to position $c+1$, i.e. the first column of $\mathcal{B}(\mathcal{S}^c_{i \dots j})$.
\item Swap the rows such that all identical letters are bundled together, and the bundles are arranged down the column with decreasing sizes, i.e.
\begin{align}\label{eq:col}
\left[\begin{array}{c}
\mathcal{S}^{c+1}_{i \dots j,1}\\
\mathcal{S}^{c+1}_{i \dots j,2}\\
\vdots \\
\mathcal{S}^{c+1}_{i \dots j,H}\\
\end{array}\right]_t
\textit{ such that \ }
||\mathcal{S}^{c+1}_{i \dots j,1}||_t \geq
||\mathcal{S}^{c+1}_{i \dots j,2}||_t \geq
\dots \geq
||\mathcal{S}^{c+1}_{i \dots j,H}||_t
\end{align}

\end{enumerate}


\item Since the Bundled Form is unique, we need to select some of the many $t$-columns before proceeding. We do so by fixing $h \in \{1,2,\dots,H\} = \mathcal{H}$ and checking all $t \in \mathcal{T}$:

\begin{enumerate}
\item Starting from $h=1$, find $Max \{||\mathcal{S}^{c+1}_{i \dots j,h}||_t\}_{t\in\mathcal{T}}$, and keep only the indices $t \in \mathcal{T}$ that yield $||\mathcal{S}^{c+1}_{i \dots j,h}||_t = Max \{||\mathcal{S}^{c+1}_{i \dots j,h}||_t\}_{t\in\mathcal{T}}$.

\item If the index set $\mathcal{T}$ still contains more than one element, i.e. $||\mathcal{T}||>1$, repeat 2.1 for $h=h+1$ with $Max \{||\mathcal{S}^{c+1}_{i \dots j,h+1}||_t\}_{t\in\mathcal{T}}$.





\item If the process terminates when:

\begin{enumerate}
\item $||\mathcal{T}||=1$.

Then there is a unique column $c+1$ with the bundles 
$\{
\mathcal{S}^{c+1}_{i \dots j,1},
\mathcal{S}^{c+1}_{i \dots j,2},
\dots,
\mathcal{S}^{c+1}_{i \dots j,H}
\}$. Repeat the algorithm from step 1 for each of the sub-block codes 
$$
\mathcal{B}(\mathcal{S}^{c+1}_{i \dots j,1}),
\mathcal{B}(\mathcal{S}^{c+1}_{i \dots j,2}),
\dots,
\mathcal{B}(\mathcal{S}^{c+1}_{i \dots j,H})
$$

\item $||\mathcal{T}||>1$ at $h=H$.

Then there are several $t$-columns like e.q.(\ref{eq:col}). For each $t \in \mathcal{T}$, repeat the algorithm from step 1 for each of the sub-block codes
$$
\mathcal{B}(\mathcal{S}^{c+1}_{i \dots j,1})_t,
\mathcal{B}(\mathcal{S}^{c+1}_{i \dots j,2})_t,
\dots,
\mathcal{B}(\mathcal{S}^{c+1}_{i \dots j,H})_t
$$



Note that the index set $\mathcal{T}$ can expand due to \emph{multiplicity} when step 1 is repeated. For example, $t=1$ under multiplicity is expanded from an element to a set of sub-indices $t=1 \mapsto \{11,12,13,\dots,1u\}$ for some $u$. Update the index set $\mathcal{T}$ so that it is a set of sets: 
$$\mathcal{T} = \{ 
\{11,12,13,\dots,1u\},
\{21,22,23,\dots,2u_2\},
\dots,
\{T1,T2,T3,\dots,Tu_T\}
 \}$$

Now, the recursive version of e.q. (\ref{eq:col}) is

\begin{align}\label{eq:col2}
\left[\begin{array}{c}
\mathcal{S}^{c+2}_{i \dots j,h,1}\\
\mathcal{S}^{c+2}_{i \dots j,h,2}\\
\vdots \\
\mathcal{S}^{c+2}_{i \dots j,h,G}\\
\end{array}\right]_t
\textit{ such that \ }
||\mathcal{S}^{c+2}_{i \dots j,h,1}||_t \geq
||\mathcal{S}^{c+2}_{i \dots j,h,2}||_t \geq
\dots \geq
||\mathcal{S}^{c+2}_{i \dots j,h,G}||_t
\end{align}


Step 2 is repeated with a modification for recursion: fix $h \in \mathcal{H}$, fix $g \in \{1,2,\dots,G\}=\mathcal{G}$, and check all $t \in \mathcal{T}$.


For each value for $h\in \mathcal{H}$, run through index $g \in \mathcal{G}$. Whenever a sub-index $tv \in \mathcal{T}$ is deleted, delete also from $\mathcal{T}$ the entire set containing the sub-index
$$\{t1, t2, \dots, tv, \dots, tu_t \}$$


\end{enumerate}


\end{enumerate}





\item The algorithm will eventually terminate and produce a unique Bundled Form. This gives the solution to the \textbf{special case} of the problem, i.e. without letter-permutation.

Alternatively, we can apply letter-permutation so that the sub-bundles belonging to the same super-bundle have increasing letter-value down the column. This gives the unique \emph{Bundled Form Class Representation of a block code}.


\end{enumerate}







\begin{lemma}\label{lem:uniq}
The termination of the algorithm and the uniqueness of the Bundled Form are guaranteed.
\end{lemma}
\begin{proof}
This is because the algorithm ranks the potential Bundled Forms by comparing the sizes of the bundles down each column. When the ranking is indeterminate, it then repeats the comparison on the next column. The process ends at column $p$ when the ``finest refinement'' is obtained and $||\mathcal{S}^{p}_{i \dots,e}||=1$, due to the non-repeating rows. 


Alternatively, one can imagine rewriting each column of the potential Bundled Forms with a vertical string of number representing the bundle sizes.The algorithm essentially ranks all potential bundled forms by comparing the digits down the string, and then the digits down the substrings.

Due to the \emph{Well-Ordering Principle}, there must be a potential Bundled Form with the highest rank, or several Bundled Forms with the same highest rank. For the latter, simply perform letter-permutation to yield the unique \emph{Bundled Form Class Representation of a block code}, and we are done.
\end{proof}




\begin{theorem}\label{thm:same}
Block codes of the same class have the same Bundled Form.
\end{theorem}
\begin{proof}
This is straighforward. Since the algorithm obeys all the operations that define the block code classes, it does not change the class of a block code. Therefore, all the block codes in a class can be transformed into the same unique \emph{Bundled Form Class Representation}.
\end{proof}

Also, block codes of different classes have different Bundled Forms, or else this would contradict Theorem \ref{thm:same}.



\section{Conclusion}
This paper sets out to solve the problem of the identification of the class of a block code. We do so by introducing a new \emph{Canonical Bundled Form} as a unique class representation of the block code.


The Bundled Form and its algorithm too solves the special problem of determining the equivalence between matrices under column/row swapping, and the general problem which allows column-wise letter-permutation to the sub-problem. Row-permutation can be done by transposing the matrices.




\section{Citations}


H. Fripertinger. Enumeration, construction and random generation of block codes. \emph{Designs, Codes and Cryptography,} Volume 14 Issue 3: 213-219, 1998.




\end{document} 

